/// Copyright © 2023, Oct. Developed by Mouaz M. Al-Shahmeh
/// https://malshahmeh.web.app
/// APIGuide package
/// Define [SecuritySchemeType] options
enum SecuritySchemeType {
  /// Query API Key
  /// Some APIs use API keys for authorization.
  /// An API key is a token that a client provides when making API calls.
  /// The key can be sent in the query string:
  /// GET /something?api_key=abcdef12345
  /// API keys are supposed to be a secret that only the client
  /// and server know.
  /// Like Basic authentication,
  /// API key-based authentication is only considered secure if used
  /// together with other security mechanisms such as HTTPS/SSL.
  /// https://swagger.io/docs/specification/authentication/api-keys/
  QueryAPIKey(
    /// Security Scheme Title
    title: 'API Key',

    /// Security Scheme Description
    description:
        'An API key is a token that you provide when making API calls. Include the token in a query parameter.',
  ),

  /// Header API Key
  /// Some APIs use API keys for authorization.
  /// An API key is a token that a client provides when making API calls.
  /// The key can be sent in the request header:
  /// GET /something HTTP/1.1
  /// X-API-Key: abcdef12345
  /// API keys are supposed to be a secret that only the client
  /// and server know.
  /// Like Basic authentication,
  /// API key-based authentication is only considered secure if used
  /// together with other security mechanisms such as HTTPS/SSL.
  /// https://swagger.io/docs/specification/authentication/api-keys/
  HeaderAPIKey(
    /// Security Scheme Title
    title: 'API Key',

    /// Security Scheme Description
    description:
        'An API key is a token that you provide when making API calls. Include the token in a header parameter.',
  ),

  /// Cookie API Key
  /// Some APIs use API keys for authorization.
  /// An API key is a token that a client provides when making API calls.
  /// The key can be sent as a cookie:
  /// GET /something HTTP/1.1
  /// Cookie: X-API-KEY=abcdef12345
  /// API keys are supposed to be a secret that only the client
  /// and server know.
  /// Like Basic authentication,
  /// API key-based authentication is only considered secure if used
  /// together with other security mechanisms such as HTTPS/SSL.
  /// https://swagger.io/docs/specification/authentication/api-keys/
  CookieAPIKey(
    /// Security Scheme Title
    title: 'API Key',

    /// Security Scheme Description
    description:
        'An API key is a token that you provide when making API calls. Include the token in a cookie parameter.',
  ),

  /// Basic HTTP
  /// Basic authentication is a simple authentication scheme built
  /// into the HTTP protocol.
  /// The client sends HTTP requests with the Authorization header
  /// that contains the word Basic word followed by a space and
  /// a base64-encoded string username:password.
  /// For example, to authorize as demo / p@55w0rd the client would send
  /// Authorization: Basic ZGVtbzpwQDU1dzByZA==
  /// https://swagger.io/docs/specification/authentication/basic-authentication/
  BasicHTTP(
    /// Security Scheme Title
    title: 'Basic Auth',

    /// Security Scheme Description
    description:
        'Basic authentication is a simple authentication scheme built into the HTTP protocol. To use it, send your HTTP requests with an Authorization header that contains the word Basic followed by a space and a base64-encoded string username:password.',
  ),

  /// Bearer HTTP
  /// Bearer authentication (also called token authentication)
  /// is an HTTP authentication scheme that involves security
  /// tokens called bearer tokens.
  /// The name “Bearer authentication” can be understood as
  /// “give access to the bearer of this token.”
  /// The bearer token is a cryptic string,
  /// usually generated by the server in response to a login request.
  /// The client must send this token in the Authorization header
  /// when making requests to protected resources:
  /// Authorization: Bearer <token>
  /// https://swagger.io/docs/specification/authentication/bearer-authentication/
  BearerHTTP(
    /// Security Scheme Title
    title: 'Bearer Auth',

    /// Security Scheme Description
    description:
        'Provide your bearer token in the Authorization header when making requests to protected resources.',
  ),

  /// Digest HTTP
  /// With Digest auth, the client sends a first request to the API,
  /// and the server responds with a few details,
  /// including a number that can be used only once (a nonce),
  /// a realm value, and a 401 unauthorized response.
  /// You then send back an encrypted array of data including
  /// a username and password combined with the data received from
  /// the server in the first request.
  /// The server uses the passed data to generate an encrypted
  /// string and compares it against what you sent
  /// to authenticate your request.
  /// https://learning.postman.com/docs/sending-requests/authorization/digest-auth/
  DigestHTTP(
    /// Security Scheme Title
    title: 'Digest Auth',

    /// Security Scheme Description
    description:
        'Provide your encrypted digest scheme data in the Authorization header when making requests to protected resources.',
  ),

  /// Hoba HTTP
  /// HTTP Origin-Bound Authentication (HOBA) is a digital-signature-based
  /// design for an HTTP authentication method.
  /// The design can also be used in JavaScript-based authentication
  /// embedded in HTML.  HOBA is an alternative to HTTP
  /// authentication schemes that require passwords and therefore
  /// avoids all problems related to passwords,
  /// such as leakage of server-side password databases.
  /// https://datatracker.ietf.org/doc/html/rfc7486
  HobaHTTP(
    /// Security Scheme Title
    title: 'Hoba Auth',

    /// Security Scheme Description
    description:
        'HTTP Origin-Bound Authentication (HOBA) is a digital-signature-based design for an HTTP authentication method. The design can also be used in JavaScript-based authentication embedded in HTML. HOBA is an alternative to HTTP authentication schemes that require passwords and therefore avoids all problems related to passwords, such as leakage of server-side password databases.',
  ),

  /// Mutual HTTP
  /// Mutual authentication is when two sides of a communications channel
  /// verify each other's identity, instead of only one side
  /// verifying the other.
  /// Mutual authentication is also known
  /// as "two-way authentication" because the process
  /// goes in both directions.
  /// https://www.cloudflare.com/learning/access-management/what-is-mutual-authentication/
  MutualHTTP(
    /// Security Scheme Title
    title: 'Mutual Auth',

    /// Security Scheme Description
    description:
        'Mutual authentication is when two sides of a communications channel verify each other\'s identity, instead of only one side verifying the other. Mutual authentication is also known as "two-way authentication" because the process goes in both directions.',
  ),

  /// Negotiate HTTP
  /// Negotiate authentication automatically selects between
  /// the Kerberos protocol and NTLM authentication,
  /// depending on availability.
  /// The Kerberos protocol is used if it's available;
  /// otherwise, NTLM is tried.
  /// Kerberos authentication significantly improves upon NTLM.
  /// Kerberos authentication is both faster than NTLM and allows
  /// the use of mutual authentication and delegation
  /// of credentials to remote machines.
  /// https://learn.microsoft.com/en-us/dotnet/framework/wcf/feature-details/understanding-http-authentication
  NegotiateHTTP(
    /// Security Scheme Title
    title: 'Negotiate Auth',

    /// Security Scheme Description
    description:
        'Negotiate authentication automatically selects between the Kerberos protocol and NTLM authentication, depending on availability. The Kerberos protocol is used if it\'s available; otherwise, NTLM is tried. Kerberos authentication significantly improves upon NTLM. Kerberos authentication is both faster than NTLM and allows the use of mutual authentication and delegation of credentials to remote machines.',
  ),

  /// OAuth HTTP
  /// OAuth provides a method for clients to access server resources on
  /// behalf of a resource owner (such as a different client or an end-
  /// user).  It also provides a process for end-users to authorize third-
  /// party access to their server resources without sharing their
  /// credentials (typically, a username and password pair), using user-
  /// agent redirections.
  /// https://datatracker.ietf.org/doc/html/rfc5849
  OAuthHTTP(
    /// Security Scheme Title
    title: 'OAuth Auth',

    /// Security Scheme Description
    description:
        'OAuth provides a method for clients to access server resources on behalf of a resource owner (such as a different client or an end-user).  It also provides a process for end-users to authorize third-party access to their server resources without sharing their credentials (typically, a username and password pair), using user-agent redirections.',
  ),

  /// Scram-sha-1 HTTP
  /// SCRAM-SHA-1 is the default authentication method
  /// for MongoDB versions 3.0, 3.2, 3.4, and 3.6.
  /// SCRAM-SHA-1 is a salted challenge-response mechanism
  /// (SCRAM) that uses your username and password,
  /// encrypted with the SHA-1 algorithm to authenticate your user.
  /// https://www.mongodb.com/docs/drivers/node/v3.6/fundamentals/authentication/mechanisms/
  ScramSHA1HTTP(
    /// Security Scheme Title
    title: 'Scram-sha-1 Auth',

    /// Security Scheme Description
    description:
        'SCRAM-SHA-1 is the default authentication method for MongoDB versions 3.0, 3.2, 3.4, and 3.6. SCRAM-SHA-1 is a salted challenge-response mechanism (SCRAM) that uses your username and password, encrypted with the SHA-1 algorithm to authenticate your user.',
  ),

  /// Scram-sha-256 HTTP
  /// SCRAM-SHA-256 is the default authentication method for MongoDB
  /// starting in version 4.0.
  /// SCRAM-SHA-256 is a salted challenge-response
  /// authentication mechanism (SCRAM) that uses your username and password,
  /// encrypted with the SHA-256 algorithm to authenticate your user.
  /// https://www.mongodb.com/docs/drivers/node/v3.6/fundamentals/authentication/mechanisms/
  ScramSHA256HTTP(
    /// Security Scheme Title
    title: 'Scram-sha-256 Auth',

    /// Security Scheme Description
    description:
        'SCRAM-SHA-256 is the default authentication method for MongoDB starting in version 4.0. SCRAM-SHA-256 is a salted challenge-response authentication mechanism (SCRAM) that uses your username and password, encrypted with the SHA-256 algorithm to authenticate your user.',
  ),

  /// Vapid HTTP
  /// Voluntary Application Server Identification (VAPID)
  /// The "vapid" authentication scheme allows
  /// a client to include its identity in a
  /// signed token with requests that it makes. The signature can be used
  /// by the push service to attribute requests that are made by the same
  /// application server to a single entity. The identification
  /// information can allow the operator of a push service to contact the
  /// operator of the application server. The signature can be used to
  /// restrict the use of a push message subscription to a single
  /// application server.
  /// https://www.rfc-editor.org/rfc/rfc8292.html
  VapidHTTP(
    /// Security Scheme Title
    title: 'Vapid Auth',

    /// Security Scheme Description
    description:
        'The "vapid" authentication scheme allows a client to include its identity in a signed token with requests that it makes. The signature can be used by the push service to attribute requests that are made by the same application server to a single entity. The identification information can allow the operator of a push service to contact the operator of the application server. The signature can be used to restrict the use of a push message subscription to a single application server.',
  ),

  /// OAuth2
  /// The Password grant type is a legacy way to exchange a user's
  /// credentials for an access token.
  /// Because the client application has to collect
  /// the user's password and send it to the authorization server,
  /// it is not recommended that this grant be used at all anymore.
  /// This flow provides no mechanism for things like multifactor
  /// authentication or delegated accounts,
  /// so is quite limiting in practice.
  /// https://oauth.net/2/grant-types/password/
  OAuth2PasswordFlow(
    /// Security Scheme Title
    title: 'OAuth 2.0 - Password OAuth Flow',

    /// Security Scheme Description
    description:
        'The Password grant type is a legacy way to exchange a user\'s credentials for an access token. Because the client application has to collect the user\'s password and send it to the authorization server, it is not recommended that this grant be used at all anymore. This flow provides no mechanism for things like multifactor authentication or delegated accounts, so is quite limiting in practice.',
  ),

  /// OAuth2
  /// Implicit OAuth Flow
  /// The Implicit flow was a simplified OAuth flow previously
  /// recommended for native apps and JavaScript apps where the access
  /// token was returned immediately without an extra
  /// authorization code exchange step.
  /// It is not recommended to use the implicit flow
  /// (and some servers prohibit this flow entirely) due to
  /// the inherent risks of returning access tokens in an HTTP
  /// redirect without any confirmation that it has been received
  /// by the client.
  /// https://oauth.net/2/grant-types/implicit/
  OAuth2ImplicitFlow(
    /// Security Scheme Title
    title: 'OAuth 2.0 - Implicit OAuth Flow',

    /// Security Scheme Description
    description:
        'The resource owner password credentials grant type is suitable in cases where the resource owner has a trust relationship with the client, such as the device operating system or a highly privileged.',
  ),

  /// OAuth2
  /// Authorization Code OAuth Flow
  /// The Authorization Code Flow (defined in OAuth 2.0 RFC 6749, section 4.1),
  /// involves exchanging an authorization code for a token.
  /// This flow can only be used for confidential applications
  /// (such as Regular Web Applications) because the application's
  /// authentication methods are included in the exchange
  /// and must be kept secure.
  /// https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow
  OAuth2CodeFlow(
    /// Security Scheme Title
    title: 'OAuth 2.0 - Authorization Code OAuth Flow',

    /// Security Scheme Description
    description:
        'The Authorization Code Flow (defined in OAuth 2.0 RFC 6749, section 4.1), involves exchanging an authorization code for a token. This flow can only be used for confidential applications (such as Regular Web Applications) because the application\'s authentication methods are included in the exchange and must be kept secure.',
  ),

  /// OAuth2
  /// Client Credentials OAuth Flow
  /// The Client Credentials Flow (defined in OAuth 2.0 RFC 6749, section 4.4)
  /// involves an application exchanging its application credentials,
  /// such as client ID and client secret, for an access token.
  /// This flow is best suited for Machine-to-Machine (M2M) applications,
  /// such as CLIs, daemons, or backend services,
  /// because the system must authenticate and
  /// authorize the application instead of a user.
  /// https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow
  OAuth2ClientFlow(
    /// Security Scheme Title
    title: 'OAuth 2.0 - Client Credentials OAuth Flow',

    /// Security Scheme Description
    description:
        'The Client Credentials Flow (defined in OAuth 2.0 RFC 6749, section 4.4) involves an application exchanging its application credentials, such as client ID and client secret, for an access token. This flow is best suited for Machine-to-Machine (M2M) applications, such as CLIs, daemons, or backend services, because the system must authenticate and authorize the application instead of a user.',
  ),

  /// OAuth 2.0
  /// The OAuth 2.0 authorization framework enables a third-party
  /// application to obtain limited access to an HTTP service, either on
  /// behalf of a resource owner by orchestrating an approval interaction
  /// between the resource owner and the HTTP service, or by allowing the
  /// third-party application to obtain access on its own behalf.  This
  /// specification replaces and obsoletes the OAuth 1.0 protocol described
  /// in RFC 5849.
  /// https://datatracker.ietf.org/doc/html/rfc6749
  OAuth2(
    /// Security Scheme Title
    title: 'OAuth 2.0',

    /// Security Scheme Description
    description:
        'The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf. This specification replaces and obsoletes the OAuth 1.0 protocol described  in RFC 5849.',
  ),

  /// OpenID Connect Protocol
  /// OpenID Connect (OIDC) is an interoperable authentication protocol
  /// based on the OAuth 2.0 framework of specifications
  /// (IETF RFC 6749 and 6750). It simplifies the way to verify
  /// the identity of users based on the authentication performed
  /// by an Authorization Server and to obtain user profile
  /// information in an interoperable and REST-like manner.
  /// OpenID Connect enables application and website developers
  /// to launch sign-in flows and receive verifiable assertions
  /// about users across Web-based, mobile, and JavaScript clients.
  /// And the specification suite is extensible to support a range of
  /// optional features such as encryption of identity data,
  /// discovery of OpenID Providers, and session logout.
  /// https://openid.net/developers/how-connect-works/
  OpenIDConnect(
    /// Security Scheme Title
    title: 'OpenID Connect',

    /// Security Scheme Description
    description:
        'OpenID Connect is an interoperable authentication protocol based on the OAuth 2.0 framework of specifications (IETF RFC 6749 and 6750). It simplifies the way to verify the identity of users based on the authentication performed by an Authorization Server and to obtain user profile information in an interoperable and REST-like manner.',
  );

  /// Define [SecuritySchemeType] constructor
  const SecuritySchemeType({
    /// Use title property as required attribute
    required this.title,

    /// Use description property as required attribute
    required this.description,
  });

  /// Define [title] property as String and final
  final String title;

  /// Define [description] property as String and final
  final String description;
}
